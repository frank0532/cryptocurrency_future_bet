{
  "language": "Solidity",
  "sources": {
    "contracts/CryptocurrencyFutureBet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.16;\r\n\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol\";\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\n\r\nuint256 constant MINDAYS = 7;\r\nuint256 constant MAXDAYS = 1000;\r\n\r\nerror CryptocurrencyFutureBet__NotEnoughETHEntered();\r\nerror CryptocurrencyFutureBet__BetOver();\r\nerror CryptocurrencyFutureBet__NotEnoughWithdraw(uint256 maxWithdraw);\r\nerror CryptocurrencyFutureBet__NotEnoughMargin(uint256 maxAvailableMargin);\r\nerror CryptocurrencyFutureBet__InvertStr2NumError(string numStr);\r\n\r\ncontract CryptocurrencyFutureBet is KeeperCompatibleInterface {\r\n    mapping(uint256 => Bet) private s_allBets;\r\n    mapping(string => AggregatorV3Interface) private s_feedData;\r\n    mapping(address => uint256) private s_playersMargin;\r\n    uint256 private s_betId = 0;\r\n    uint256 private immutable i_minBet;\r\n    string[] private s_betsLines;\r\n\r\n    event BetEnter(address indexed player, string symbol, int256 targetPrice, uint256 endTime);\r\n    event ABetSettled(uint256 indexed indexId, string desc);\r\n\r\n    struct Bet {\r\n        bool settled;\r\n        string symbol;\r\n        uint64 startTime;\r\n        uint64 stopTime;\r\n        uint64 targetTime;\r\n        int256 targetPrice;\r\n        int256 realPrice;\r\n        address creator;\r\n        address[] playersList;\r\n        uint256 upsSum;\r\n        uint256 downsSum;\r\n        mapping(address => uint256) betsUp;\r\n        mapping(address => uint256) betsDown;\r\n    }\r\n\r\n    constructor(uint256 minBet) {\r\n        i_minBet = minBet;\r\n    }\r\n\r\n    function withDrawAll() public {\r\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\r\n        require(success);\r\n    }\r\n\r\n    function withDraw(uint256 amount) external {\r\n        if (amount > s_playersMargin[msg.sender]) {\r\n            revert CryptocurrencyFutureBet__NotEnoughWithdraw(s_playersMargin[msg.sender]);\r\n        }\r\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\r\n        require(success);\r\n        s_playersMargin[msg.sender] = s_playersMargin[msg.sender] - amount;\r\n    }\r\n\r\n    function checkUpkeep(bytes memory checkData)\r\n        public\r\n        override\r\n        returns (bool upkeepNeeded, bytes memory)\r\n    {}\r\n\r\n    function performUpkeep(bytes calldata) external override {\r\n        for (uint256 i = 0; i < s_betId; i++) {\r\n            if (s_allBets[i].targetTime <= block.timestamp) {\r\n                aBetSettlement(i);\r\n            }\r\n        }\r\n    }\r\n\r\n    function aBetSettlement(uint256 betIndex) private {\r\n        if (!s_allBets[betIndex].settled) {\r\n            (int256 realPrice, ) = getPrice(s_allBets[betIndex].symbol);\r\n            int256 direct = realPrice - s_allBets[betIndex].targetPrice;\r\n            if (s_allBets[betIndex].upsSum == 0 && s_allBets[betIndex].downsSum == 0) {} else {\r\n                if (s_allBets[betIndex].upsSum > 0 && s_allBets[betIndex].downsSum > 0) {\r\n                    if (direct < 0) {\r\n                        for (uint256 i = 0; i < s_allBets[betIndex].playersList.length; i++) {\r\n                            address playeri = s_allBets[betIndex].playersList[i];\r\n                            s_playersMargin[playeri] =\r\n                                s_playersMargin[playeri] +\r\n                                s_allBets[betIndex].betsDown[playeri] +\r\n                                (s_allBets[betIndex].betsDown[playeri] /\r\n                                    s_allBets[betIndex].downsSum) *\r\n                                s_allBets[betIndex].upsSum;\r\n                        }\r\n                    } else {\r\n                        for (uint256 i = 0; i < s_allBets[betIndex].playersList.length; i++) {\r\n                            address playeri = s_allBets[betIndex].playersList[i];\r\n                            s_playersMargin[playeri] =\r\n                                s_playersMargin[playeri] +\r\n                                s_allBets[betIndex].betsUp[playeri] +\r\n                                (s_allBets[betIndex].betsUp[playeri] / s_allBets[betIndex].upsSum) *\r\n                                s_allBets[betIndex].downsSum;\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (s_allBets[betIndex].upsSum == 0) {\r\n                        for (uint256 i = 0; i < s_allBets[betIndex].playersList.length; i++) {\r\n                            address playeri = s_allBets[betIndex].playersList[i];\r\n                            s_playersMargin[playeri] =\r\n                                s_playersMargin[playeri] +\r\n                                s_allBets[betIndex].betsDown[playeri];\r\n                        }\r\n                    } else {\r\n                        for (uint256 i = 0; i < s_allBets[betIndex].playersList.length; i++) {\r\n                            address playeri = s_allBets[betIndex].playersList[i];\r\n                            s_playersMargin[playeri] =\r\n                                s_playersMargin[playeri] +\r\n                                s_allBets[betIndex].betsUp[playeri];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            s_allBets[betIndex].settled = true;\r\n            emit ABetSettled(betIndex, s_betsLines[betIndex]);\r\n        }\r\n    }\r\n\r\n    function betTrace(\r\n        uint256 betIndex,\r\n        int8 direct,\r\n        address player,\r\n        uint256 amount\r\n    ) private {\r\n        if (amount < i_minBet) {\r\n            revert CryptocurrencyFutureBet__NotEnoughETHEntered();\r\n        }\r\n        if (block.timestamp > s_allBets[betIndex].stopTime) {\r\n            revert CryptocurrencyFutureBet__BetOver();\r\n        }\r\n        if (\r\n            (s_allBets[betIndex].betsUp[player] == 0) && (s_allBets[betIndex].betsDown[player] == 0)\r\n        ) {\r\n            s_allBets[betIndex].playersList.push(player);\r\n        }\r\n        if (direct > 0) {\r\n            s_allBets[betIndex].betsUp[player] = s_allBets[betIndex].betsUp[player] + amount;\r\n            s_allBets[betIndex].upsSum = s_allBets[betIndex].upsSum + amount;\r\n        } else {\r\n            s_allBets[betIndex].betsDown[player] = s_allBets[betIndex].betsDown[player] + amount;\r\n            s_allBets[betIndex].downsSum = s_allBets[betIndex].downsSum + amount;\r\n        }\r\n        emit BetEnter(\r\n            player,\r\n            s_allBets[betIndex].symbol,\r\n            s_allBets[betIndex].targetPrice,\r\n            s_allBets[betIndex].targetTime\r\n        );\r\n    }\r\n\r\n    function payFromWallet(uint256 betIndex, int8 direct) external payable {\r\n        betTrace(betIndex, direct, msg.sender, msg.value);\r\n    }\r\n\r\n    function payFromMargin(\r\n        uint256 betIndex,\r\n        int8 direct,\r\n        uint256 amount\r\n    ) external {\r\n        if (s_playersMargin[msg.sender] >= amount) {\r\n            betTrace(betIndex, direct, msg.sender, amount);\r\n            s_playersMargin[msg.sender] = s_playersMargin[msg.sender] - amount;\r\n        } else {\r\n            revert CryptocurrencyFutureBet__NotEnoughMargin(s_playersMargin[msg.sender]);\r\n        }\r\n    }\r\n\r\n    function createBet(\r\n        string calldata symbol,\r\n        uint64 targetTime,\r\n        string calldata targetPriceInt,\r\n        string calldata targetPriceDecimals,\r\n        address feedDataAddress\r\n    ) external {\r\n        uint64 startTime = uint64(block.timestamp);\r\n        uint64 offsetDays = (targetTime - startTime) / 86400;\r\n        require(\r\n            (offsetDays >= MINDAYS) && (offsetDays <= MAXDAYS),\r\n            string(\r\n                abi.encodePacked(\r\n                    \"'offsetDays'should be in[\",\r\n                    Strings.toString(MINDAYS),\r\n                    \",\",\r\n                    Strings.toString(MAXDAYS),\r\n                    \").\"\r\n                )\r\n            )\r\n        );\r\n        s_allBets[s_betId].settled = false;\r\n        s_allBets[s_betId].symbol = symbol;\r\n        s_allBets[s_betId].startTime = startTime;\r\n        s_allBets[s_betId].stopTime = (startTime + targetTime) / 2;\r\n        s_allBets[s_betId].targetTime = targetTime;\r\n        s_allBets[s_betId].creator = msg.sender;\r\n        s_feedData[symbol] = AggregatorV3Interface(feedDataAddress);\r\n        uint8 decimals = s_feedData[symbol].decimals();\r\n        int256 TargetPrice = int256(\r\n            str2uint(targetPriceInt) *\r\n                (10**decimals) +\r\n                str2uint(targetPriceDecimals) *\r\n                (10**(decimals - uint8(bytes(targetPriceDecimals).length)))\r\n        );\r\n        s_allBets[s_betId].targetPrice = TargetPrice;\r\n        s_betsLines.push(\r\n            string(\r\n                abi.encodePacked(\r\n                    symbol,\r\n                    \",\",\r\n                    Strings.toString(s_allBets[s_betId].startTime),\r\n                    \",\",\r\n                    Strings.toString(s_allBets[s_betId].stopTime),\r\n                    \",\",\r\n                    Strings.toString(s_allBets[s_betId].targetTime),\r\n                    \",\",\r\n                    targetPriceInt,\r\n                    \".\",\r\n                    targetPriceDecimals\r\n                )\r\n            )\r\n        );\r\n        s_betId = s_betId + 1;\r\n    }\r\n\r\n    function getABetDetails(uint256 betIndex)\r\n        external\r\n        view\r\n        returns (\r\n            address[] memory,\r\n            string memory,\r\n            string memory\r\n        )\r\n    {\r\n        uint256 playersNum = s_allBets[betIndex].playersList.length;\r\n        string memory betsUp = \"\";\r\n        string memory betsDown = \"\";\r\n\r\n        for (uint256 i = 0; i < playersNum; i++) {\r\n            address playeri = s_allBets[betIndex].playersList[i];\r\n            uint256 upi = s_allBets[betIndex].betsUp[playeri];\r\n            uint256 downi = s_allBets[betIndex].betsDown[playeri];\r\n            betsUp = string(abi.encodePacked(betsUp, Strings.toString(upi), \",\"));\r\n            betsDown = string(abi.encodePacked(betsDown, Strings.toString(downi), \",\"));\r\n        }\r\n        return (s_allBets[betIndex].playersList, betsUp, betsDown);\r\n    }\r\n\r\n    function getABetAsset(uint256 betIndex)\r\n        external\r\n        view\r\n        returns (uint256 upsSum, uint256 downsSum)\r\n    {\r\n        upsSum = s_allBets[betIndex].upsSum;\r\n        downsSum = s_allBets[betIndex].downsSum;\r\n    }\r\n\r\n    function getABetStatus(uint256 betIndex) external view returns (bool) {\r\n        return (s_allBets[betIndex].settled);\r\n    }\r\n\r\n    function getAllBetsLines() external view returns (string[] memory) {\r\n        return (s_betsLines);\r\n    }\r\n\r\n    function getPrice(string memory symbol) public view returns (int256, uint8) {\r\n        (, int256 price, , , ) = s_feedData[symbol].latestRoundData();\r\n        uint8 decimals = s_feedData[symbol].decimals();\r\n        return (price, decimals);\r\n    }\r\n\r\n    function getAvailableMargin() external view returns (uint256) {\r\n        return s_playersMargin[msg.sender];\r\n    }\r\n\r\n    function getMinBet() external view returns (uint256) {\r\n        return (i_minBet);\r\n    }\r\n\r\n    function getBetsLinesNum() external view returns (uint256) {\r\n        return (s_betId);\r\n    }\r\n\r\n    function str2uint(string calldata strNum) public pure returns (uint256 num) {\r\n        for (uint256 i = 0; i < bytes(strNum).length; i++) {\r\n            if ((uint8(bytes(strNum)[i]) - 48) < 0 || (uint8(bytes(strNum)[i]) - 48) > 9) {\r\n                revert CryptocurrencyFutureBet__InvertStr2NumError(strNum);\r\n            }\r\n            num += (uint8(bytes(strNum)[i]) - 48) * 10**(bytes(strNum).length - i - 1);\r\n        }\r\n        return (num);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * @notice This is a deprecated interface. Please use AutomationCompatibleInterface directly.\n */\npragma solidity ^0.8.0;\nimport {AutomationCompatibleInterface as KeeperCompatibleInterface} from \"./AutomationCompatibleInterface.sol\";\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AutomationCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}